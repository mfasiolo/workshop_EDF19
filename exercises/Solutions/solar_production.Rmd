---
title: "Solar production modelling: solution"
output:
  html_document:
    number_sections: yes
    toc: yes
  pdf_document:
    toc: yes
---

<!--
%\VignetteEngine{rmarkdown::render}
%\VignetteIndexEntry{qgam_vignette}
-->
  
```{r setup, include=FALSE}
library(knitr)
library(rgl)
opts_chunk$set(out.extra='style="display:block; margin: auto"', fig.align="center", tidy=FALSE)
knit_hooks$set(webgl = hook_webgl)
```

```{r setup1, include=FALSE}
# Set workdir to source file location and then
source(file = "my_settings.R")
library(RhpcBLASctl); blas_set_num_threads(1)
```

1) Load data and separate it into training and testing set:
```{r dbbmi1, message = F}
library(mgcViz);
load(paste0(goodLocation, "/data/solar_prod.rda")) # change this

set.seed(515)
iTest <- sample(1:nrow(solar_prod), 2000)
DataTEST <- solar_prod[iTest, ]
DataTRAIN <- solar_prod[-iTest, ]
```

2) Fit median quantile GAM and look at tensor effect:
```{r dbbmi2, message = F, webgl=TRUE}
fitQ <- qgamV(logprod ~ dow + te(Posan, Instant, bs = c("cc", "cc"), k = c(5, 5)),
                        data=DataTRAIN, qu = 0.5)


plotRGL( sm(fitQ, 1), residuals = TRUE )
```
The `rgl` plot shows a clear pattern in the residuals sign along `Instant`. We can have a better look using `l_gridCheck2D`:
```{r dbbmi3, message = F}
check2D(fitQ, "Posan", "Instant") + l_gridCheck2D(function(.x) mean(.x<0), stand = F)
```

3) We increase the number of basis functions along `Instant` and refit:
```{r dbbmi4, message = F}
fitQ2 <- qgamV(logprod ~ dow + te(Posan, Instant, bs = c("cc", "cc"), k = c(5, 15)),
                data=DataTRAIN, qu = 0.5)

check2D(fitQ2, "Posan", "Instant") + l_gridCheck2D(function(.x) sum(.x<0)/length(.x))

AIC(fitQ, fitQ2)
```
Residual sign less evident, and AIC much improved!

4) Fit multiple quantiles:
```{r dbbmi5, message = F}
qus = seq(0.1, 0.9, length.out = 5)
fitMQ <- mqgamV(logprod ~ dow + te(Posan, Instant, bs = c("cc", "cc"), k = c(5, 15)),
                 data=DataTRAIN, qus)
```

Predict from median model, and plot the pinball loss vs `Instant`:
```{r dbbmi6, message = F}
prQ05 <- predict(fitMQ[[3]], newdata = DataTEST)

pinloss <- function(y, mu, qu){
  tau <- 1 - qu
  d <- y - mu
  l <- d * 0
  l[d < 0] <- - tau*d[d<0]
  l[d > 0] <- - (tau-1)*d[d>0]
  return( l )
}

tmp <- pinloss(DataTEST$logprod, prQ05, 0.5)
plot(DataTEST$Instant, tmp, ylab = "pinball loss")
```
We get large losses near to sunrise and sunset, possibly because solar production surges or collapses very suddenly at those times: 
```{r dbbmi7, message = F}
plot(solar_prod$Instant[1:200], solar_prod$logprod[1:200])
```

5) Fit Gaulss GAM and plot tensor effect on variance:
```{r dbbmi8, message = F}
fitLSS <- gamV(list(logprod ~ dow + te(Posan, Instant, bs= c("cc", "cc"), k = c(5, 15)),
                            ~ dow + te(Posan, Instant, bs= c("cc", "cc"), k = c(5, 5))), 
               family = gaulss, data=DataTRAIN, aViz = list(nsim = 50))

plot(fitLSS, select = 2)
```
There are four spikes in the variance effect. These are probably attributable to the fact that the production surge (collapse) at sunrise (sunset) is difficult to capture with a non-adaptive smooth effect. Futher the time of day at which sunrise happens changes at the fastest rate around the equinoxes, hence it makes sense having higher variance around `Posan = 0.25` and `Posan = 0.75`.

6) We fit a standard Gaussian GAM:
```{r dbbmi9, message = F}
fitGAUS <- gamV(logprod ~ te(Posan, Instant, bs= c("cc", "cc"), k = c(5, 15)), data=solar_prod)
```
Then we produce predictions for each quantile and model: 
```{r dbbmi10, message = F}
prQv <- sapply(1:5, # QGAM
               function(.ii){
                 predict(fitMQ[[.ii]], newdata = DataTEST)
               })

prGAUSv <- sapply(1:5, # GAUSSIAN GAM
                  function(.ii){
                    qnorm(qus[.ii], predict(fitGAUS, newdata = DataTEST), sqrt(fitGAUS$sig2))
                  })

prLSSv <- sapply(1:5, # GAULSS
                 function(.ii){
                   tmp <- predict(fitLSS, newdata = DataTEST, type = "response")
                   qnorm(qus[.ii], tmp[ , 1], 1/tmp[ , 2])
                 })
```

We calculate the pinball loss corresponding to each quantile and method, and we plot them:
```{r dbbmi11, message = F}
pinlossvett <- function(y, mu, p){
  n <- length( p )
  out <- sapply(1:n,
                function(ii){
                  return( sum(pinloss(y, mu[ , ii], p[ii])) )
                })
  return( out )
}
lossQv <- pinlossvett(DataTEST$logprod, prQv, qus)
lossGAUSv <- pinlossvett(DataTEST$logprod, prGAUSv, qus)
lossLSSv <- pinlossvett(DataTEST$logprod, prLSSv, qus)

plot(qus, lossQv/lossGAUSv, col = 2, ylim = c(0.7, 1.05), type = 'b')
abline(h=1)
lines(qus, lossLSSv/lossGAUSv, col = 3, type = 'b')
```
Here black is loss under Gaussian GAM, red is QGAM and green is GAULSS. The quantile GAM model is better for any quantile, and particularly good for the highest quantile.

7) The GAULSS model does not capture well the residuals distribution:
```{r dbbmi12, message = F}
qq(fitLSS)
```

We fit a `shash` model, which seems to do better:
```{r dbbmi13, message = F}
library(mgcFam)
fitShash <- gamV(list(logprod ~ dow + te(Posan, Instant, bs= c("cc", "cc"), k = c(5, 15)),
                      ~ dow + te(Posan, Instant, bs= c("cc", "cc"), k = c(5, 5)), 
                      ~ 1, 
                      ~ 1), 
                 family = shash, data=DataTRAIN, aViz = list(nsim = 50))

qq(fitShash)

AIC(fitGAUS, fitLSS, fitShash)
```

We then include it in the comparison by predicting the quantiles under this model, and calculating the pinball loss:
```{r dbbmi14, message = F}
prShashv <- sapply(1:5,    
                   function(.ii){
                     fitShash$family$qf(qus[.ii], 
                                        predict(fitShash, newdata = DataTEST, type = "response"),
                                        wt = fitShash$prior.weights, 1)
                   })

lossShashv <- pinlossvett(DataTEST$logprod, prShashv, qus)

# Plotting relative scores
plot(qus, lossQv/lossGAUSv, col = 2, ylim = c(0.7, 1.15), type = 'b')
abline(h=1)
lines(qus, lossLSSv/lossGAUSv, col = 3, type = 'b')
lines(qus, lossShashv/lossGAUSv, col = 4, type = 'b')
```
`shash` does better than a normal on the top quantile but, surprisingly, it performs quite badly below the median.